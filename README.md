# Deque README


## 项目概述

在小作业中，大家已经使用过STL的 `std::deque` 的头尾插入删除功能，实际上，`std::deque` 也支持类似普通数组那样的随机下标访问。


<img src="https://www.oreilly.com/api/v2/epubs/9781787120952/files/assets/fd7f0c6e-e5cb-400d-ad2f-c38e91772682.png" width="500">

在这次大作业中，你需要使用分块链表（Unrolled Linked List）数据结构实现高效的双端队列（Deque），支持快速随机访问与动态容量调整。所需要实现的接口在给定的文件中。

## 核心要求

分块链表就是对存储元素进行分块，以加速随机访问等操作。理想情况下，每一块的大小在 $O(\sqrt n)$ 量级。一种保证方法是在块过大时分成两块，相邻两块均很小时合成一块。在具体实现中，每一
块内部的储存方式和所有块的储存方式均可使用链表或数组。 你需要保证头尾插入和删除的均摊
复杂度是 $O(1)$，随机插入、删除和查询的复杂度是最坏 $O(\sqrt n)$。

这次的大作业不允许使用STL容器，但你可以使用你上次写的双向链表，直接粘贴进 `src.hpp` 即可。这次任务的几乎所有测试都在下发的文件中，其中带有 memcheck 的测试仅是其原始测试数据更少
的版本，可用作检查内存泄漏和内存错误。

我们在此提供两种可以考虑的实现方式：一种是链表套链表，另一种的链表套循环数组，一般来说后一种实现的效率会更高一些。**注：你的实现必须包括动态调整块长的策略，不允许固定块长**

## 项目结构

```
.
├── tests/
│   ├── one/             # 功能测试用例
│   ├── two/      
│   ├── three/      
│   ├── four/      
│   ├── two.memcheck/    # 内存检查专用测试
│   └── four.memcheck/    
├── (various utility hpp files...)
├── README.md            # 你给deque写的文档
└── deque.hpp            # 你的deque实现
```

## 对于 `README.md` 的要求

你需要在 `README.md` 中给出自己分裂和合并的策略，并说明为什么时间复杂度符合要求。

**Note: 如果说明非常清晰，会有额外1-5分加分**

另附：最好认真写，因为我们 CR 的时候一定会问

## 时间安排

这次大作业的发布时间为2025年3月10日，截止时间是2025年4月7日

## 策略说明

### 策略:
- **插入时：** 当某个块的元素个数超过 $2\sqrt{n}$ 时，将该块分裂成两个相等大小的块。
- **删除时：** 当某个块的元素个数小于 $\frac{\sqrt{n}}{2}$ 时，将该块和紧邻的下一块（如果有的话）合并成一块。

---

### 1. 头尾插入与删除操作

#### 实际代价

- **常规情况：**  
  代价为 $O(1)$。

- **特殊情况：**   
  当边界块因插入而超过 $2\sqrt{n}$ 或因删除而低于 $\frac{\sqrt{n}}{2}$ 时，会触发分裂或合并操作，此时单次操作可能需要移动 $O(\sqrt{n})$ 个元素，导致实际代价为 $O(\sqrt{n})$。

#### 均摊成本  

- **插入时（触发分裂）：**  
  当某个块经过连续插入后，块内元素个数达到了 $2\sqrt{n}$。该过程至少经历 $\sqrt{n}$ 次插入，均摊到每次插入操作上的额外开销仍为 $O(1)$。  
  该实现对于分裂操作设置了最小块长保证不出现空块。这对复杂度的影响应该是常数级别的。

- **删除时（触发合并）：**  
  当某个块经过连续删除后，其元素个数降至 $\frac{\sqrt{n}}{2}$ 以下，触发合并操作。该过程至少包含 $\sqrt{n}$ 次**插入+删除**。合并操作需要移动 $O(\sqrt{n})$ 个元素，均摊下来，每次删除的额外成本为 $O(1)$。

因此，头尾插入与删除操作的均摊时间复杂度均为 $O(1)$。

---

### 2. 随机插入、删除与查询操作

#### 最坏情况分析

- **随机查询：**  
  最坏情况下需要遍历所有块的大小查询到最后一个元素。块的数量为 $O(\sqrt{n})$，块内元素数量也为 $O(\sqrt{n})$ 。因此时间上界为 $O(\sqrt{n})$。

- **随机插入与删除：**  
  随机插入与删除操作等价于先随机查询到位置再移动块内元素进行插入/删除。  
  最坏情况下，查询代价为 $O(\sqrt{n})$。在块内移动所有元素的代价为 $O(\sqrt{n})$。加上可能触发分裂或合并操作，单次随机插入或删除操作的时间上界为 $O(\sqrt{n})$。  